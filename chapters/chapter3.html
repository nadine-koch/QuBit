<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Quantengatter</title>
    <link rel="stylesheet" href="../styles.css"/>
</head>
<body data-key="chapter3"
      data-questionsnumber="4">

<div class="side-menu" id="sideMenu">
    <button class="burger">‚ò∞</button>
    <a href="../index.html">üè† Landing Page</a>
    <a id="level0" class="unlocked" href="../chapters/chapter0.html">Relevanz</a>
    <a id="level1" class="unlocked" href="../chapters/chapter1.html">Was ist ein Qubit?</a>
    <a id="level2" class="unlocked" href="../chapters/chapter2.html">Quantenschaltkreise</a>
    <a id="level3" class="unlocked" href="#">Anwendungsbeispiel Quantenschaltkreise</a>
</div>

<header>
    <button class="burger">‚ò∞</button>
    <h1>Quantenschaltkreise</h1>
    <div class="progress-header" id="progressHeader">
        <progress id="xp-bar" value="0" max="100"></progress>
        <span id="xp-text">0 / 100 XP</span>
    </div>
</header>
<main>
    <!-- STORY INTRO -->
    <section class="story-section">
        <h2>Mission: Erste Schaltkreise</h2>
        <div class="npc-container">
            <img src="../images/NPC.png" alt="NPC Figur">
            <div class="speech-bubble">
                <p>
                    Wir sind da ‚Äì direkt √ºber Tensora. Unser Problem wartet da unten:
                    Der <strong>Kontrollkern der Forschungsstation</strong> antwortet nicht stabil. Die klassischen Routinen
                    laufen hei√ü. Eine <em>Quanten-Steuerlogik</em> sollte abhilfe leisten.
                </p>
            </div>
        </div>

        <p>
            Das Raumschiff dockt an.
            Ihr eilt Richtung Kontrollkern, um die neue Quantenlogik zu implementieren.
        </p>

    </section>

    <!-- LEARNING CONTENT BEGINS -->
    <section class="learning-section">
    <h2>Beispiel: Grover-Algorithmus</h2>
    <p>
        Ein Beispiel f√ºr Quantenschaltkreise ist der <strong>Grover-Algorithmus</strong>.
        Er wird verwendet, um ein bestimmtes <strong>Element</strong> in einer <strong>unsortierten Datenbank</strong> zu finden ‚Äì eine Aufgabe, die
        klassisch im Durchschnitt <strong><em>O(N)</em></strong> Schritte ben√∂tigt.
        <br>
        Mithilfe von Quantenvorteilen reduziert sich die ben√∂tigte Anzahl der Schritte auf nur etwa
        <strong><em>O(‚àöN)</em></strong>. Damit ist der Algorithmus <strong>quadratisch schneller</strong> als jedes klassische Verfahren.
    </p>
    <h4>Funktionsweise des Groveralgorithmus</h4>
    <p>
        Das Grundprinzip des Algorithmus funktioniert wie folgt:<br>
        Alle m√∂glichen Zust√§nde werden gleichzeitig durch eine Pr√ºfungsroutine gepr√ºft. Diese Routine
        nennen wir Orakel.<br>
        Das gesuchte Element wird markiert, alle anderen Elemente bleiben unver√§ndert.
        <br>
        Bei Quantenalgorithmen haben wir jedoch das "Problem", dass die Messung auf Wahrscheinlichkeiten basiert.
        Die falschen L√∂sungen st√∂ren das Ergebnis der Messung.
        Damit wir am Ende beim Messen nicht von den falschen Zust√§nden ‚Äû√ºberstimmt‚Äú werden,
        sorgt ein Weiterer Schritt im Algorithmus daf√ºr, dass die richtige L√∂sung viel wahrscheinlicher gemessen wird.
        Diesen weiteren Schritt nennen wir Diffusion ‚Äì in diesem Schritt wird der Diffusionsoperator angewendet.
        Dieser Operator sorgt daf√ºr, dass die Wahrscheinlichkeiten der falschen L√∂sungen gezielt gemindert werden.
        Damit erscheint die gesuchte L√∂sung mit hoher Wahrscheinlichkeit.
    </p>

    <p>
        Mit der Superposition kann ein Qubit in den Zust√§nden |0‚ü© und |1‚ü© gleichzeitig sein.
        Diesen Vorteil macht sich der Grover Algorithmus zu nutze.
        Im Grover Algorithmus werden die Qubits zu Beginn in die Superposition gebracht.
        Damit repr√§sentieren die Qubits die gesamte Menge der Elemente die durchsucht werden soll.
        Jedes Element wird zur gleichen Wahrscheinlichkeit durch die Qubits repr√§sentiert.
    </p>

    <div class="info-box">
        Hat der Grover Algorithmus beispielsweise drei Qubits die alle in der Superposition sind,
        dann repr√§sentieren alle drei Qubits jeweils zu 50% |0‚ü© und zu 50% |1‚ü©.<br>
        Damit ergeben sich die Zust√§nde |000‚ü©, |001‚ü©, |010‚ü©, ... |111‚ü©,
        die alle mit gleicher Wahrscheinlichkeit vorkommen.
        Diese Zust√§nde entsprechen den Eintr√§gen einer Datenbank.
    </div>

    <p>
        Um das gesuchte Element aus der Menge der Elemente zu finden, wird das Orakel (also die Pr√ºfungsroutine) angewendet.
        Dieses Orakel soll eine falsche L√∂sung (also alle Elemente die nicht gesucht sind) gleich lassen.
        Wenn der Zustand |000‚ü© nicht gesucht ist bedeutet das folgendes: \( Orakel|000‚ü© = |000‚ü© \)
        Wenn das Orakel jedoch auf einen gesuchten Zustand angewendet wird, dann soll dieser Zustand markiert werden.
        Mathematisch ausgedr√ºckt, bedeutet das: \( Orakel|001‚ü© = -|001‚ü© \)
        Auf den gesuchten Zustand wurde ein Phasen flip durchgef√ºhrt. Der Zustand wurde "markiert".
    </p>

    <p>
        Damit diese Markierung beim Messen tats√§chlich sichtbar wird, folgt als n√§chster Schritt der Diffusionsoperator.
        Er verst√§rkt die Wahrscheinlichkeit des markierten Zustands und schw√§cht die Wahrscheinlichkeiten der √ºbrigen Zust√§nde ab.
        Durch die wiederholte Anwendung von "Orakel + Diffusion" wird der gesuchte Zustand immer wahrscheinlicher.
        Am Ende gen√ºgt eine Messung, um mit hoher Wahrscheinlichkeit den gesuchten Zustand zu erhalten.
    </p>
    <div class="npc-container">
        <img src="../images/NPC.png" alt="Prof. Qubitnik">
        <div class="speech-bubble">
             <p>Welches Gatter f√ºhrt zu einem Phasenflip?</p>
             <label>
                <select id="quiz-phase-flip">
                    <option disabled selected>-- W√§hle eine Antwort --</option>
                    <option>Hadamard-Gatter</option>
                    <option>Pauli-Z-Gatter</option>
                    <option>Pauli-X-Gatter</option>
                    <option>Swap-Gatter</option>
                </select>
            </label>
        </div>
    </div>
<p>
    Der Schaltplan des Grover-Algorithmus besteht im Wesentlichen aus folgenden Schritten:
</p>
<ol>
    <li><strong>Initialisierung:</strong> Alle Qubits starten im Zustand \( |0\rangle \) und werden in die Superposition gebracht. Dadurch werden alle m√∂glichen
        Zust√§nde des Systems repr√§sentiert.</li>
    <li><strong>Orakel (in Abbildung rot umrandet):</strong> Ein spezieller Schaltkreis markiert den gesuchten Zustand, indem er dessen Phase
        umkehrt. Mathematisch bedeutet das: Der Vektor des gesuchten Zustands erh√§lt ein Minuszeichen, w√§hrend
        alle anderen unver√§ndert bleiben.</li>
    <li><strong>Diffusionsoperator (in Abbildung schwarz umrandet):</strong> Verst√§rkt die Wahrscheinlichkeit (Amplitude) der markierten L√∂sung und
        schw√§cht die √ºbrigen Zust√§nde ab.</li>
    <li><strong>Messung:</strong> Nach einigen Wiederholungen von Orakel + Diffusion wird der gesuchte Zustand mit
        hoher Wahrscheinlichkeit gemessen.</li>
</ol>

<div style="text-align: center; margin: 20px 0;">
    <img src="../images/Grover_Algorithmus_Marked.jpg" alt="Schaltplan des Grover-Algorithmus" class="qc-grover-circuit"/>
    <p>Hinweis: Die im Bild als RX dargestellten Operatoren entsprechen dem Pauli X Gatter.</p>
</div>
<div style="border-left: 4px solid #2196F3; background-color: #f1f8ff; padding: 12px; margin: 20px 0;">
    <p>
        <strong>Was macht die c4 Leitung?</strong><br>
        Die unterste Leitung (c4) stellt das klassische Register dar.
        Sie dient als Messleitung, auf der die Ergebnisse der Quantenmessungen abgelegt werden.
        Jedes Messergebnis wird dabei als klassisches Bit (0 oder 1) gespeichert.
    </p>
</div>
        <h4>Ancilla Qubit</h4>
        <p>In Schaltkreisen werden manchmal sogenannte Ancilla Qubits verwendet. Diese Qubits sind sogenannte Hilfsqubits.
            In unserer obigen Schaltung ist das vierte Qubit von oben (mit der Bezeichnung <em>q[3]</em>) ein Ancilla Qubit. Es hilft uns f√ºr eine kurze Zeit aus, wird allerdings
            nicht gemessen. Es enth√§lt keine relevanten Daten die gemessen werden m√ºssen.
            Ancilla Qubits helfen tempor√§r, um bestimmte Rechnungen oder Kontrollaufgaben zu √ºbernehmen.
            Im Schaltkreis werden sie wie ein "normales" Qubit dargestellt und verwendet.
            Der einzige Unterschied zu "normalen" Qubits liegt darin, dass sie nicht die eigentlichen Informationen des Algorithmus speichern, sondern nur tempor√§r helfen.</p>
        <p>Das mehrfach kontrollierte Z kann beispielsweise mit einem Ancilla Qubit ausgef√ºhrt werden. Das Hilfsqubit flippt die Phase (Pauli Z Operation), wenn die
            controll-Qubits 1 sind. Das Ancilla Qubit speichert damit das Ergebnis dieser Operation ab.</p>

        <p><strong>Wie funktioniert das Orakel?</strong></p>
        <p>
            Angenommen, das gesuchte Element ist 010.
            Das Herzst√ºck des Orakels ist ein <em>mehrfach kontrolliertes Z-Gatter</em>. Dieses Gatter f√ºgt eine
            Phasen√§nderung (ein Minuszeichen) genau dann hinzu, wenn die Steuerqubits in einem bestimmten Zustand
            sind. Das Problem: Es ‚Äûschaltet‚Äú eigentlich nur, wenn die Steuerqubits alle 1 sind
            (also beim Zustand 111).
        </p>
        <p>
            Um trotzdem andere Muster wie 010 markieren zu k√∂nnen, trickst man:
            Mit <strong>Pauli-X-Gattern</strong> werden vorher einzelne Bits invertiert, sodass aus
            010 f√ºr einen Moment 111 wird.
            Dann reagiert das kontrollierte Z wie gew√ºnscht und markiert diesen Zustand.
            Danach setzt man mit denselben Pauli-X-Gattern alles wieder zur√ºck, sodass die urspr√ºnglichen Qubits
            unver√§ndert weiterlaufen.
        </p>
        <p>
            Wichtig ist: Das Orakel misst nichts!
            Stattdessen wird die Phase des gesuchten Zustands ver√§ndert. Dadurch unterscheidet sich dieser Zustand
            zwar nicht in seiner Wahrscheinlichkeit, aber er ‚Äûsteht nun anders im Raum‚Äú und kann im n√§chsten Schritt
            (Diffusion) gezielt verst√§rkt werden.
        </p>

        <p>
            Vielleicht fragst du dich jetzt: ‚ÄûAber wie <em>suche</em> ich denn eigentlich? Ich muss doch jeden Zustand
            mit der gesuchten L√∂sung vergleichen?‚Äú ‚Äì Genau das √ºbernimmt das Orakel f√ºr uns.
            Der Trick liegt darin, dass alle m√∂glichen Zust√§nde des Systems gleichzeitig in der Superposition vorhanden sind.
            Das Orakel pr√ºft also nicht <em>einen Zustand nach dem anderen</em> (wie ein klassischer Computer),
            sondern es wendet die Markierungsregel <strong>parallel auf alle Zust√§nde gleichzeitig</strong> an.
            Dadurch ‚Äûwei√ü‚Äú das System nach dem Orakel-Schritt, welcher Zustand besonders behandelt wird
            ‚Äì ohne dass jeder Vergleich einzeln durchgef√ºhrt werden muss.
        </p>


        <div style="border-left: 4px solid #2196F3; background-color: #f1f8ff; padding: 12px; margin: 20px 0;">
            <p><strong>Warum braucht man den Diffusionsoperator?</strong></p>
            <p>
                Nach dem Orakel ist das gesuchte Element markiert, aber seine Wahrscheinlichkeit ist noch genauso klein
                wie die aller anderen Zust√§nde. Der Diffusionsoperator sorgt daf√ºr, dass die Amplitude (also die
                Wahrscheinlichkeit beim Messen) des markierten Zustands schrittweise <strong>verst√§rkt</strong> wird,
                w√§hrend die der anderen Zust√§nde verringert wird.
            </p>
            <p>
                Man kann sich das so vorstellen: Der Gesamtzustand aller Qubits ist wie eine Welle. Durch das Orakel wird
                die Phase des gesuchten Zustands umgedreht, und durch den Diffusionsoperator ‚Äûkippt‚Äú die Welle so, dass
                die Amplitude genau dieses Zustands w√§chst. Nach einigen Wiederholungen sticht die gesuchte L√∂sung
                deutlich hervor.
            </p>
            <p>
                Optimalerweise wird der Algorithmus genau
                \( \frac{\pi}{4} \sqrt{\frac{N}{M}} \) mal iteriert. N ist die Anzahl der m√∂glichen Zust√§nde (z. B. bei
                3 Qubits also \( N = 2^3 = 8 \)), M ist die Anzahl der gesuchten Zust√§nde (z. B. 1).
                F√ºhrt man mehr Iterationen durch, tritt der sogenannte <em>Souffl√©-Effekt</em> auf: Die Wahrscheinlichkeit
                f√ºr die gesuchten Zust√§nde steigt zun√§chst an, f√§llt danach aber wieder ab ‚Äì die L√∂sung wird wieder
                ‚Äûverwischt‚Äú.
            </p>
            </div>
        </section>

    <section class="learning-section" id="final-quiz">
        <h3>Kontrollkern-Stabilisation</h3>

        <div class="npc-container">
            <img src="../images/NPC.png" alt="Prof. Qubitnik">
            <div class="speech-bubble">
                <p>Du willst den Zustand <code>001</code> mit einem mehrfach kontrollierten Z markieren.
                    Welche Vor-/Nachbereitung ist korrekt?
                    <br>
                    Hinweis: X steht f√ºr Pauli X. CCZ steht f√ºr controlled (erstes Qubit) controlled (zweites Qubit) Z (drittes Qubit).
                </p>
                <label>
                    <select id="quiz-mark-001">
                        <option disabled selected>-- W√§hle eine Antwort --</option>
                        <option>X auf q2 und q1 ‚Üí CCZ ‚Üí X auf q2 und q1</option>
                        <option>X auf q0 ‚Üí CCZ ‚Üí X auf q0</option>
                        <option>CCZ ohne Vor- und Nachbereitung</option>
                        <option>H auf allen ‚Üí CCZ ‚Üí H auf allen</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="npc-container">
            <img src="../images/NPC.png" alt="Prof. Qubitnik denkt nach">
            <div class="speech-bubble">
                <p>F√ºr eine Suche √ºber <code>N=8</code> Zust√§nde mit genau <code>M=1</code> Treffer ‚Äì
                    wie viele Grover-Iterationen sind optimal (gerundet)?</p>
                <label>
                    <select id="quiz-iterations">
                        <option disabled selected>-- W√§hle eine Antwort --</option>
                        <option>1</option>
                        <option>2</option>
                        <option>3</option>
                        <option>4</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="npc-container">
            <img src="../images/NPC.png" alt="Prof. Qubitnik erkl√§rt das Orakel">
            <div class="speech-bubble">
                <p><strong>Frage 3:</strong> Im Grover-Orakel sollen <em>zwei</em> Zielzust√§nde markiert werden, z. B. <code>|010‚ü©</code> und <code>|101‚ü©</code>.
                    Wie baust du den Orakel-Teil im Schaltkreis korrekt auf?</p>
                <label>
                    <select id="quiz-oracle-multi-target">
                        <option disabled selected>-- W√§hle eine Antwort --</option>
                        <option>Nur den Diffusionsoperator zweimal anwenden ‚Äì der markiert automatisch mehrere Zust√§nde.</option>
                        <option>Ein einziges mehrfach-kontrolliertes Z verwenden und hoffen, dass beide Muster getroffen werden.</option>
                        <option>Zwei Orakel-Bl√∂cke nacheinander: F√ºr jeden Zielzustand passende X-Vor-/Nachschaltungen, dann ein mehrfach-kontrolliertes Z, danach die Xs wieder r√ºckg√§ngig machen.</option>
                        <option>Zwischen den beiden Markierungen messen, damit der erste Treffer ‚Äûfixiert‚Äú wird.</option>
                    </select>
                </label>
            </div>
        </div>

        <p id="final-prompt" style="margin-top:.6rem;color:#b00020;">
            In einem Terminal wird <em>Time is ticking ...</em> angezeigt.
        </p>

        <div id="final-scene" style="display:none; margin-top:1rem;">
            <div class="npc-container">
                <img src="../images/NPC.png" alt="Prof. Qubitnik erleichtert">
                <div class="speech-bubble">
                    <p><strong>Stabilisierung erfolgreich!</strong> Die Warnlichter erl√∂schen, der Kontrollkern synchronisiert sich.
                        Die Verarbeitung der Daten funktioniert wieder erfolgreich. Gro√üartige Arbeit!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- show final act when hitting 100 XP -->
    <script type="module">
        import { getXP } from "../js/progressStorage.js";
        function maybeRevealEnding() {
            const key = document.body.dataset.key;
            const scene = document.getElementById("final-scene");
            const prompt = document.getElementById("final-prompt");
            const done = getXP(key) >= 100;
            scene.style.display = done ? "block" : "none";
            if (prompt) prompt.style.display = done ? "none" : "block";
        }
        document.addEventListener("DOMContentLoaded", maybeRevealEnding);
        document.addEventListener("xpChanged", (e) => {
            if (e.detail?.key === document.body.dataset.key) maybeRevealEnding();
        });
    </script>
    <div class="chapter-nav">
        <a class="chapter-btn prev" href="../chapters/chapter2.html">
            ‚Üê Vorheriges Kapitel
        </a>
    </div>

</main>
<footer>
    &copy; 2025 Quantenreise ¬∑ Gemeinsam Quanten entdecken!
</footer>

<script type="module">
    import { setupBurgerMenu } from "../js/burgerMenu.js";
    setupBurgerMenu();
</script>

<script type="module" src="../js/quizQuestions.js"></script>
<script type="module" src="../js/progressStorage.js"></script>
<script type="module">
    import { guardAccess } from "../js/levelLock.js";

    guardAccess("chapter2", "chapter3", 100);
</script>
<script type="module" src="../js/stickyHeaderProgressBar.js"></script>
<script type="module" src="../js/chapterNavigation.js"></script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</body>
</html>